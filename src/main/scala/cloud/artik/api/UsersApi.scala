/**
 * ARTIK Cloud API
 * No descripton provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cloud.artik.api

import cloud.artik.model.PropertiesEnvelope
import cloud.artik.model.AppProperties
import cloud.artik.model.UserEnvelope
import cloud.artik.model.DeviceTypesEnvelope
import cloud.artik.model.DevicesEnvelope
import cloud.artik.model.RulesEnvelope
import io.swagger.client.ApiInvoker
import io.swagger.client.ApiException

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date

import scala.collection.mutable.HashMap

class UsersApi(val defBasePath: String = "https://api.artik.cloud/v1.1",
                        defApiInvoker: ApiInvoker = ApiInvoker) {
  var basePath = defBasePath
  var apiInvoker = defApiInvoker

  def addHeader(key: String, value: String) = apiInvoker.defaultHeaders += key -> value 

  /**
   * Create User Application Properties
   * Create application properties for a user
   * @param userId User Id 
   * @param properties Properties to be updated 
   * @param aid Application ID (optional)
   * @return PropertiesEnvelope
   */
  def createUserProperties (userId: String, properties: AppProperties, aid: String) : Option[PropertiesEnvelope] = {
    // create path and map variables
    val path = "/users/{userId}/properties".replaceAll("\\{format\\}","json").replaceAll("\\{" + "userId" + "\\}",apiInvoker.escape(userId))


    val contentTypes = List("application/json", "application/json")
    val contentType = contentTypes(0)

    // query params
    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (properties == null) throw new Exception("Missing required parameter 'properties' when calling UsersApi->createUserProperties")

    if(String.valueOf(aid) != "null") queryParams += "aid" -> aid.toString
    
    
    var postBody: AnyRef = properties

    if(contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart()
      
      postBody = mp
    }
    else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[PropertiesEnvelope]).asInstanceOf[PropertiesEnvelope])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Delete User Application Properties
   * Deletes a user&#39;s application properties
   * @param userId User Id 
   * @param aid Application ID (optional)
   * @return PropertiesEnvelope
   */
  def deleteUserProperties (userId: String, aid: String) : Option[PropertiesEnvelope] = {
    // create path and map variables
    val path = "/users/{userId}/properties".replaceAll("\\{format\\}","json").replaceAll("\\{" + "userId" + "\\}",apiInvoker.escape(userId))


    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    // query params
    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if(String.valueOf(aid) != "null") queryParams += "aid" -> aid.toString
    
    
    var postBody: AnyRef = null

    if(contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart()
      
      postBody = mp
    }
    else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[PropertiesEnvelope]).asInstanceOf[PropertiesEnvelope])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get Current User Profile
   * Get&#39;s the current user&#39;s profile
   * @return UserEnvelope
   */
  def getSelf () : Option[UserEnvelope] = {
    // create path and map variables
    val path = "/users/self".replaceAll("\\{format\\}","json")
    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    // query params
    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

        
    
    var postBody: AnyRef = null

    if(contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart()
      
      postBody = mp
    }
    else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[UserEnvelope]).asInstanceOf[UserEnvelope])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get User Device Types
   * Retrieve User&#39;s Device Types
   * @param userId User ID. 
   * @param offset Offset for pagination. (optional)
   * @param count Desired count of items in the result set (optional)
   * @param includeShared Optional. Boolean (true/false) - If false, only return the user&#39;s device types. If true, also return device types shared by other users. (optional)
   * @return DeviceTypesEnvelope
   */
  def getUserDeviceTypes (userId: String, offset: Integer, count: Integer, includeShared: Boolean) : Option[DeviceTypesEnvelope] = {
    // create path and map variables
    val path = "/users/{userId}/devicetypes".replaceAll("\\{format\\}","json").replaceAll("\\{" + "userId" + "\\}",apiInvoker.escape(userId))


    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    // query params
    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if(String.valueOf(offset) != "null") queryParams += "offset" -> offset.toString
if(String.valueOf(count) != "null") queryParams += "count" -> count.toString
if(String.valueOf(includeShared) != "null") queryParams += "includeShared" -> includeShared.toString
    
    
    var postBody: AnyRef = null

    if(contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart()
      
      postBody = mp
    }
    else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[DeviceTypesEnvelope]).asInstanceOf[DeviceTypesEnvelope])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get User Devices
   * Retrieve User&#39;s Devices
   * @param userId User ID 
   * @param offset Offset for pagination. (optional)
   * @param count Desired count of items in the result set (optional)
   * @param includeProperties Optional. Boolean (true/false) - If false, only return the user&#39;s device types. If true, also return device types shared by other users. (optional)
   * @return DevicesEnvelope
   */
  def getUserDevices (userId: String, offset: Integer, count: Integer, includeProperties: Boolean) : Option[DevicesEnvelope] = {
    // create path and map variables
    val path = "/users/{userId}/devices".replaceAll("\\{format\\}","json").replaceAll("\\{" + "userId" + "\\}",apiInvoker.escape(userId))


    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    // query params
    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if(String.valueOf(offset) != "null") queryParams += "offset" -> offset.toString
if(String.valueOf(count) != "null") queryParams += "count" -> count.toString
if(String.valueOf(includeProperties) != "null") queryParams += "includeProperties" -> includeProperties.toString
    
    
    var postBody: AnyRef = null

    if(contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart()
      
      postBody = mp
    }
    else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[DevicesEnvelope]).asInstanceOf[DevicesEnvelope])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get User application properties
   * Get application properties of a user
   * @param userId User Id 
   * @param aid Application ID (optional)
   * @return PropertiesEnvelope
   */
  def getUserProperties (userId: String, aid: String) : Option[PropertiesEnvelope] = {
    // create path and map variables
    val path = "/users/{userId}/properties".replaceAll("\\{format\\}","json").replaceAll("\\{" + "userId" + "\\}",apiInvoker.escape(userId))


    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    // query params
    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if(String.valueOf(aid) != "null") queryParams += "aid" -> aid.toString
    
    
    var postBody: AnyRef = null

    if(contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart()
      
      postBody = mp
    }
    else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[PropertiesEnvelope]).asInstanceOf[PropertiesEnvelope])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get User Rules
   * Retrieve User&#39;s Rules
   * @param userId User ID. 
   * @param excludeDisabled Exclude disabled rules in the result. (optional)
   * @param count Desired count of items in the result set. (optional)
   * @param offset Offset for pagination. (optional)
   * @return RulesEnvelope
   */
  def getUserRules (userId: String, excludeDisabled: Boolean, count: Integer, offset: Integer) : Option[RulesEnvelope] = {
    // create path and map variables
    val path = "/users/{userId}/rules".replaceAll("\\{format\\}","json").replaceAll("\\{" + "userId" + "\\}",apiInvoker.escape(userId))


    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    // query params
    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if(String.valueOf(excludeDisabled) != "null") queryParams += "excludeDisabled" -> excludeDisabled.toString
if(String.valueOf(count) != "null") queryParams += "count" -> count.toString
if(String.valueOf(offset) != "null") queryParams += "offset" -> offset.toString
    
    
    var postBody: AnyRef = null

    if(contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart()
      
      postBody = mp
    }
    else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[RulesEnvelope]).asInstanceOf[RulesEnvelope])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Update User Application Properties
   * Updates application properties of a user
   * @param userId User Id 
   * @param properties Properties to be updated 
   * @param aid Application ID (optional)
   * @return PropertiesEnvelope
   */
  def updateUserProperties (userId: String, properties: AppProperties, aid: String) : Option[PropertiesEnvelope] = {
    // create path and map variables
    val path = "/users/{userId}/properties".replaceAll("\\{format\\}","json").replaceAll("\\{" + "userId" + "\\}",apiInvoker.escape(userId))


    val contentTypes = List("application/json", "application/json")
    val contentType = contentTypes(0)

    // query params
    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (properties == null) throw new Exception("Missing required parameter 'properties' when calling UsersApi->updateUserProperties")

    if(String.valueOf(aid) != "null") queryParams += "aid" -> aid.toString
    
    
    var postBody: AnyRef = properties

    if(contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart()
      
      postBody = mp
    }
    else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[PropertiesEnvelope]).asInstanceOf[PropertiesEnvelope])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

}
