/**
 * ARTIK Cloud API
 * No descripton provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cloud.artik.api

import cloud.artik.model.TaskEnvelope
import cloud.artik.model.TaskRequest
import cloud.artik.model.MetadataEnvelope
import cloud.artik.model.TaskByDidListEnvelope
import cloud.artik.model.DeviceTypesInfoEnvelope
import cloud.artik.model.MetadataPropertiesEnvelope
import cloud.artik.model.TaskStatusesEnvelope
import cloud.artik.model.TaskStatusesHistoryEnvelope
import cloud.artik.model.TaskListEnvelope
import cloud.artik.model.MetadataQueryEnvelope
import cloud.artik.model.DeviceTypesInfo
import cloud.artik.model.TaskUpdateRequest
import cloud.artik.model.TaskUpdateResponse
import cloud.artik.model.DeviceTaskUpdateRequest
import cloud.artik.model.DeviceTaskUpdateResponse
import io.swagger.client.ApiInvoker
import io.swagger.client.ApiException

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date

import scala.collection.mutable.HashMap

class DevicesManagementApi(val defBasePath: String = "https://api.artik.cloud/v1.1",
                        defApiInvoker: ApiInvoker = ApiInvoker) {
  var basePath = defBasePath
  var apiInvoker = defApiInvoker

  def addHeader(key: String, value: String) = apiInvoker.defaultHeaders += key -> value 

  /**
   * Create a new task for one or more devices
   * Create a new task for one or more devices
   * @param taskPayload Task object to be created 
   * @return TaskEnvelope
   */
  def createTasks (taskPayload: TaskRequest) : Option[TaskEnvelope] = {
    // create path and map variables
    val path = "/devicemgmt/tasks".replaceAll("\\{format\\}","json")
    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    // query params
    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (taskPayload == null) throw new Exception("Missing required parameter 'taskPayload' when calling DevicesManagementApi->createTasks")

        
    
    var postBody: AnyRef = taskPayload

    if(contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart()
      
      postBody = mp
    }
    else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[TaskEnvelope]).asInstanceOf[TaskEnvelope])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Deletes a device&#39;s properties.
   * Deletes a device&#39;s properties.
   * @param did Device ID. 
   * @return MetadataEnvelope
   */
  def deleteServerProperties (did: String) : Option[MetadataEnvelope] = {
    // create path and map variables
    val path = "/devicemgmt/devices/{did}/serverproperties".replaceAll("\\{format\\}","json").replaceAll("\\{" + "did" + "\\}",apiInvoker.escape(did))


    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    // query params
    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

        
    
    var postBody: AnyRef = null

    if(contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart()
      
      postBody = mp
    }
    else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[MetadataEnvelope]).asInstanceOf[MetadataEnvelope])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Returns the list of tasks for a particular device id with optional status filter.
   * Returns the list of tasks for a particular device id with optional status filter.
   * @param did Device ID. 
   * @param count Max results count. (optional)
   * @param offset Result starting offset. (optional)
   * @param status Status filter. Comma-separated statuses. (optional)
   * @param order Sort results by a field. Valid fields: createdOn. (optional)
   * @param sort Sort order. Valid values: asc or desc. (optional)
   * @return TaskByDidListEnvelope
   */
  def getAllByDid (did: String, count: Integer, offset: Integer, status: String, order: String, sort: String) : Option[TaskByDidListEnvelope] = {
    // create path and map variables
    val path = "/devicemgmt/devices/{did}/tasks".replaceAll("\\{format\\}","json").replaceAll("\\{" + "did" + "\\}",apiInvoker.escape(did))


    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    // query params
    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if(String.valueOf(count) != "null") queryParams += "count" -> count.toString
if(String.valueOf(offset) != "null") queryParams += "offset" -> offset.toString
if(String.valueOf(status) != "null") queryParams += "status" -> status.toString
if(String.valueOf(order) != "null") queryParams += "order" -> order.toString
if(String.valueOf(sort) != "null") queryParams += "sort" -> sort.toString
    
    
    var postBody: AnyRef = null

    if(contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart()
      
      postBody = mp
    }
    else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[TaskByDidListEnvelope]).asInstanceOf[TaskByDidListEnvelope])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Read a device type device management information.
   * Read a device type device management information.
   * @param dtid Device type ID. 
   * @return DeviceTypesInfoEnvelope
   */
  def getDeviceTypesInfo (dtid: String) : Option[DeviceTypesInfoEnvelope] = {
    // create path and map variables
    val path = "/devicemgmt/devicetypes/{dtid}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "dtid" + "\\}",apiInvoker.escape(dtid))


    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    // query params
    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

        
    
    var postBody: AnyRef = null

    if(contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart()
      
      postBody = mp
    }
    else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[DeviceTypesInfoEnvelope]).asInstanceOf[DeviceTypesInfoEnvelope])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get a device type&#39;s device management manifest properties
   * Get a device type&#39;s device management manifest properties
   * @param dtid Device Type ID. 
   * @return MetadataPropertiesEnvelope
   */
  def getManifestProperties (dtid: String) : Option[MetadataPropertiesEnvelope] = {
    // create path and map variables
    val path = "/devicemgmt/devicetypes/{dtid}/manifest/properties".replaceAll("\\{format\\}","json").replaceAll("\\{" + "dtid" + "\\}",apiInvoker.escape(dtid))


    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    // query params
    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

        
    
    var postBody: AnyRef = null

    if(contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart()
      
      postBody = mp
    }
    else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[MetadataPropertiesEnvelope]).asInstanceOf[MetadataPropertiesEnvelope])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Read a device&#39;s properties.
   * Read a device&#39;s properties.
   * @param did Device ID. 
   * @param includeTimestamp Include timestamp. (optional)
   * @return MetadataEnvelope
   */
  def getProperties (did: String, includeTimestamp: Boolean) : Option[MetadataEnvelope] = {
    // create path and map variables
    val path = "/devicemgmt/devices/{did}/properties".replaceAll("\\{format\\}","json").replaceAll("\\{" + "did" + "\\}",apiInvoker.escape(did))


    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    // query params
    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if(String.valueOf(includeTimestamp) != "null") queryParams += "includeTimestamp" -> includeTimestamp.toString
    
    
    var postBody: AnyRef = null

    if(contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart()
      
      postBody = mp
    }
    else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[MetadataEnvelope]).asInstanceOf[MetadataEnvelope])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Returns the details and status of a task id and the individual statuses of each device id in the list.
   * Returns the details and status of a task id and the individual statuses of each device id in the list.
   * @param tid Task ID. 
   * @param count Max results count. (optional)
   * @param offset Result starting offset. (optional)
   * @param status Status filter. Comma-separated statuses. (optional)
   * @param dids Devices filter. Comma-separated device IDs. (optional)
   * @return TaskStatusesEnvelope
   */
  def getStatuses (tid: String, count: Integer, offset: Integer, status: String, dids: String) : Option[TaskStatusesEnvelope] = {
    // create path and map variables
    val path = "/devicemgmt/tasks/{tid}/statuses".replaceAll("\\{format\\}","json").replaceAll("\\{" + "tid" + "\\}",apiInvoker.escape(tid))


    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    // query params
    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if(String.valueOf(count) != "null") queryParams += "count" -> count.toString
if(String.valueOf(offset) != "null") queryParams += "offset" -> offset.toString
if(String.valueOf(status) != "null") queryParams += "status" -> status.toString
if(String.valueOf(dids) != "null") queryParams += "dids" -> dids.toString
    
    
    var postBody: AnyRef = null

    if(contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart()
      
      postBody = mp
    }
    else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[TaskStatusesEnvelope]).asInstanceOf[TaskStatusesEnvelope])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Returns the history of the status changes for a specific task id, or for a specific device id in that task.
   * Returns the history of the status changes for a specific task id, or for a specific device id in that task.
   * @param tid Task ID. 
   * @param did Device ID. Optional. (optional)
   * @return TaskStatusesHistoryEnvelope
   */
  def getStatusesHistory (tid: String, did: String) : Option[TaskStatusesHistoryEnvelope] = {
    // create path and map variables
    val path = "/devicemgmt/tasks/{tid}/statuses/history".replaceAll("\\{format\\}","json").replaceAll("\\{" + "tid" + "\\}",apiInvoker.escape(tid))


    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    // query params
    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if(String.valueOf(did) != "null") queryParams += "did" -> did.toString
    
    
    var postBody: AnyRef = null

    if(contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart()
      
      postBody = mp
    }
    else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[TaskStatusesHistoryEnvelope]).asInstanceOf[TaskStatusesHistoryEnvelope])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Returns the details and global status of a specific task id.
   * Returns the details and global status of a specific task id.
   * @param tid Task ID. 
   * @return TaskEnvelope
   */
  def getTaskByID (tid: String) : Option[TaskEnvelope] = {
    // create path and map variables
    val path = "/devicemgmt/tasks/{tid}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "tid" + "\\}",apiInvoker.escape(tid))


    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    // query params
    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

        
    
    var postBody: AnyRef = null

    if(contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart()
      
      postBody = mp
    }
    else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[TaskEnvelope]).asInstanceOf[TaskEnvelope])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Returns the all the tasks for a device type.
   * Returns the all the tasks for a device type.
   * @param dtid Device Type ID. 
   * @param count Max results count. (optional)
   * @param offset Result starting offset. (optional)
   * @param status Status filter. Comma-separated statuses. (optional)
   * @param order Sort results by a field. Valid fields: createdOn. (optional)
   * @param sort Sort order. Valid values: asc or desc. (optional)
   * @return TaskListEnvelope
   */
  def getTasks (dtid: String, count: Integer, offset: Integer, status: String, order: String, sort: String) : Option[TaskListEnvelope] = {
    // create path and map variables
    val path = "/devicemgmt/tasks".replaceAll("\\{format\\}","json")
    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    // query params
    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if(String.valueOf(dtid) != "null") queryParams += "dtid" -> dtid.toString
if(String.valueOf(count) != "null") queryParams += "count" -> count.toString
if(String.valueOf(offset) != "null") queryParams += "offset" -> offset.toString
if(String.valueOf(status) != "null") queryParams += "status" -> status.toString
if(String.valueOf(order) != "null") queryParams += "order" -> order.toString
if(String.valueOf(sort) != "null") queryParams += "sort" -> sort.toString
    
    
    var postBody: AnyRef = null

    if(contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart()
      
      postBody = mp
    }
    else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[TaskListEnvelope]).asInstanceOf[TaskListEnvelope])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Query device properties across devices.
   * Query device properties across devices.
   * @param dtid Device Type ID. 
   * @param count Max results count. (optional)
   * @param offset Result starting offset. (optional)
   * @param filter Query filter. Comma-separated key&#x3D;value pairs (optional)
   * @param includeTimestamp Include timestamp. (optional)
   * @return MetadataQueryEnvelope
   */
  def queryProperties (dtid: String, count: Integer, offset: Integer, filter: String, includeTimestamp: Boolean) : Option[MetadataQueryEnvelope] = {
    // create path and map variables
    val path = "/devicemgmt/devices/properties".replaceAll("\\{format\\}","json")
    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    // query params
    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if(String.valueOf(dtid) != "null") queryParams += "dtid" -> dtid.toString
if(String.valueOf(count) != "null") queryParams += "count" -> count.toString
if(String.valueOf(offset) != "null") queryParams += "offset" -> offset.toString
if(String.valueOf(filter) != "null") queryParams += "filter" -> filter.toString
if(String.valueOf(includeTimestamp) != "null") queryParams += "includeTimestamp" -> includeTimestamp.toString
    
    
    var postBody: AnyRef = null

    if(contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart()
      
      postBody = mp
    }
    else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[MetadataQueryEnvelope]).asInstanceOf[MetadataQueryEnvelope])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Updates a device type information
   * Updates a device type information
   * @param dtid Device type ID. 
   * @param deviceTypeInfo Device type info object to be set 
   * @return DeviceTypesInfoEnvelope
   */
  def updateDeviceTypesInfo (dtid: String, deviceTypeInfo: DeviceTypesInfo) : Option[DeviceTypesInfoEnvelope] = {
    // create path and map variables
    val path = "/devicemgmt/devicetypes/{dtid}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "dtid" + "\\}",apiInvoker.escape(dtid))


    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    // query params
    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (deviceTypeInfo == null) throw new Exception("Missing required parameter 'deviceTypeInfo' when calling DevicesManagementApi->updateDeviceTypesInfo")

        
    
    var postBody: AnyRef = deviceTypeInfo

    if(contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart()
      
      postBody = mp
    }
    else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[DeviceTypesInfoEnvelope]).asInstanceOf[DeviceTypesInfoEnvelope])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Updates a device&#39;s server properties.
   * Updates a device&#39;s server properties.
   * @param did Device ID. 
   * @param deviceProperties Device properties object to be set 
   * @return MetadataEnvelope
   */
  def updateServerProperties (did: String, deviceProperties: Any) : Option[MetadataEnvelope] = {
    // create path and map variables
    val path = "/devicemgmt/devices/{did}/serverproperties".replaceAll("\\{format\\}","json").replaceAll("\\{" + "did" + "\\}",apiInvoker.escape(did))


    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    // query params
    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

        
    
    var postBody: AnyRef = deviceProperties

    if(contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart()
      
      postBody = mp
    }
    else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[MetadataEnvelope]).asInstanceOf[MetadataEnvelope])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Updates a task for all devices - For now just allows changing the state to cancelled.
   * Updates a task for all devices - For now just allows changing the state to cancelled.
   * @param tid Task ID. 
   * @param taskUpdateRequest Task update request 
   * @return TaskUpdateResponse
   */
  def updateTask (tid: String, taskUpdateRequest: TaskUpdateRequest) : Option[TaskUpdateResponse] = {
    // create path and map variables
    val path = "/devicemgmt/tasks/{tid}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "tid" + "\\}",apiInvoker.escape(tid))


    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    // query params
    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (taskUpdateRequest == null) throw new Exception("Missing required parameter 'taskUpdateRequest' when calling DevicesManagementApi->updateTask")

        
    
    var postBody: AnyRef = taskUpdateRequest

    if(contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart()
      
      postBody = mp
    }
    else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[TaskUpdateResponse]).asInstanceOf[TaskUpdateResponse])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Updates a task for a specific device - For now just allows changing the state to cancelled.
   * Updates a task for a specific device - For now just allows changing the state to cancelled.
   * @param tid Task ID. 
   * @param did Device ID. 
   * @param deviceTaskUpdateRequest Device task update request 
   * @return DeviceTaskUpdateResponse
   */
  def updateTaskForDevice (tid: String, did: String, deviceTaskUpdateRequest: DeviceTaskUpdateRequest) : Option[DeviceTaskUpdateResponse] = {
    // create path and map variables
    val path = "/devicemgmt/tasks/{tid}/devices/{did}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "tid" + "\\}",apiInvoker.escape(tid))

.replaceAll("\\{" + "did" + "\\}",apiInvoker.escape(did))


    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    // query params
    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (deviceTaskUpdateRequest == null) throw new Exception("Missing required parameter 'deviceTaskUpdateRequest' when calling DevicesManagementApi->updateTaskForDevice")

        
    
    var postBody: AnyRef = deviceTaskUpdateRequest

    if(contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart()
      
      postBody = mp
    }
    else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[DeviceTaskUpdateResponse]).asInstanceOf[DeviceTaskUpdateResponse])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

}
